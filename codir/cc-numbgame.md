---
layout: default
---

# CodeChef - Number Game
_Jul 31 2018 0008_

Read the problem [here](https://www.codechef.com/problems/NUMBGAME) or [here](https://vjudge.net/problem/CodeChef-NUMBGAME).

### Solution

Um, the dp solution came to me pretty fast. For every test case I calculated the mod value ignoring i'th position for every $1 &le; i &le; n$ where n = length of the given string. Then for every mod value I calculated whether this can be taken to zero. It was a clear n^2 solution, until I (Neerjhor vai was the one actually :p) found out that there can be cycles. I mean, suppose you're calculating for a mod value, then taking some mode value and appending it results in the same value. Those needed to be handled. So my solution suddenly became O(T * N^3) where N is max mod, having T testcases.

Here was the trick. You can actually make a graph, as to which mod value can be generated by whom. Now just perform a simple dfs/bfs from the value = 0. The visited values will be the values which can be converted to zero.

Kode:
```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
typedef long double ld;
typedef pair<int, int> pii;
typedef pair<long long, long long> pll;
#define ff first
#define ss second
#define mp make_pair
#define pb push_back
#define ub upper_bound
#define lb lower_bound
#define all(x) (x).begin(), (x).end()
#define dbg(x) cout << " -- dbg: " << (x) << "\n"
#define FastIO ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);
const long long INF = 2000000000LL;
const long double EPS = 1e-9;

const int N = 1000000+7;
const int M = 1000+7;
int pre[N], p10[N];
int mcnt[M];
vector<int> g[M];
char s[N];
int n, m;

void preCal() {
    n = strlen(s);
    p10[0] = 1 % m;
    for(int i=1; i<=n; ++i) {
        p10[i] = (10 * p10[i-1]) % m;
    }

    pre[n] = 0;
    for(int i=n-1, j=0; i>=0; --i, ++j) {
        int d = s[i]-'0';
        pre[i] = (d*p10[j] + pre[i+1]) % m;
    }
	memset(mcnt, 0, sizeof mcnt);
    for(int i=0, carry=0, j=n-1; i<n; ++i, --j) {
        int temp = (carry * p10[j] + pre[i+1]) % m;
		mcnt[temp] += 1;
        int d = s[i]-'0';
        carry = (carry * 10 + d) % m;
        // cout << mval[i] << " <--- " << i << "\n";
    }
    for(int i=0; i<m; ++i) g[i].clear();
    for(int i=0; i<m; ++i) {
        for(int j=0; j<m; ++j) {
            if(!mcnt[j]) continue;
            int temp = (i*p10[n-1] + j) % m;
            g[temp].pb(i);
        }
    }
}

bool dp[M], vis[M];

void dfs(int u) {
    vis[u] = true;
    for(int v : g[u]) {
        if(!vis[v]) dfs(v);
    }
}

int main() {
    // FastIO;

    int t, tc=0;
    scanf("%d", &t);
    while(t--) {
        scanf("%s %d", s, &m);
        preCal();
        memset(vis, false, sizeof vis);
        dfs(0);
        int res = 0;
        for(int i=0; i<m; ++i) {
            if(vis[i]) res += mcnt[i];
		}
        printf("%d\n", res);
    }

    return 0;
}
```
They said that this problem has a simple solution. The answer is either the length itself or 0. I mean, you can win this game from every state possible or none! :v They mentioned not having a proof though.

***

{% include disqus.html %}
